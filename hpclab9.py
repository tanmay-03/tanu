# -*- coding: utf-8 -*-
"""HPClab9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FfO5mxc1WZxZ-kfqtw3y7ROEfQUN6Zmy
"""

! nvcc --version

!pip install git+https://github.com/andreinechaev/nvcc4jupyter.git

# Commented out IPython magic to ensure Python compatibility.
# %load_ext nvcc4jupyter

# Commented out IPython magic to ensure Python compatibility.
# %%cuda
# #include <stdio.h>
# #include <stdlib.h>
# #include <math.h>
# #include <cuda_runtime.h>
# 
# #define NUM_PARTICLES 1000
# #define BLOCK_SIZE 256
# 
# // Define a struct for particle properties
# typedef struct {
#     float x, y, z; // Position
#     float vx, vy, vz; // Velocity
# } Particle;
# 
# // Function to initialize particle properties
# void initializeParticles(Particle* particles, int num_particles) {
#     for (int i = 0; i < num_particles; i++) {
#         // Initialize positions randomly between 0 and 1
#         particles[i].x = (float)rand() / RAND_MAX;
#         particles[i].y = (float)rand() / RAND_MAX;
#         particles[i].z = (float)rand() / RAND_MAX;
#         // Initialize velocities randomly with a small perturbation
#         particles[i].vx = 0.01 * ((float)rand() / RAND_MAX - 0.5);
#         particles[i].vy = 0.01 * ((float)rand() / RAND_MAX - 0.5);
#         particles[i].vz = 0.01 * ((float)rand() / RAND_MAX - 0.5);
#     }
# }
# 
# // Kernel function to update particle positions and velocities on GPU
# __global__ void updateParticles(Particle* particles, int num_particles) {
#     // Calculate the index of the current particle in the array
#     int idx = blockIdx.x * blockDim.x + threadIdx.x;
#     // Ensure the index is within the range of particles
#     if (idx < num_particles) {
#         // Update particle position by adding velocity
#         particles[idx].x += particles[idx].vx;
#         particles[idx].y += particles[idx].vy;
#         particles[idx].z += particles[idx].vz;
# 
#         // Update particle velocity (for demonstration purposes)
#         particles[idx].vx += 0.01;
#         particles[idx].vy += 0.01;
#         particles[idx].vz += 0.01;
#     }
# }
# 
# int main() {
#     // Allocate memory for particles on host and device
#     Particle* particles = (Particle*)malloc(NUM_PARTICLES * sizeof(Particle));
#     Particle* d_particles;
#     cudaMalloc(&d_particles, NUM_PARTICLES * sizeof(Particle));
# 
#     // Initialize particle properties on host
#     initializeParticles(particles, NUM_PARTICLES);
#     // Copy particle data from host to device
#     cudaMemcpy(d_particles, particles, NUM_PARTICLES * sizeof(Particle), cudaMemcpyHostToDevice);
# 
#     // Print initial particle positions
#     printf("Initial particle positions:\n");
#     for (int i = 0; i < NUM_PARTICLES; i++) {
#         printf("Particle %d: (%f, %f, %f)\n", i, particles[i].x, particles[i].y, particles[i].z);
#     }
#     printf("\n");
# 
#     // Calculate number of blocks needed for kernel execution
#     int numBlocks = (NUM_PARTICLES + BLOCK_SIZE - 1) / BLOCK_SIZE;
#     // Launch kernel to update particle positions and velocities
#     updateParticles<<<numBlocks, BLOCK_SIZE>>>(d_particles, NUM_PARTICLES);
# 
#     // Copy updated particle data from device to host
#     cudaMemcpy(particles, d_particles, NUM_PARTICLES * sizeof(Particle), cudaMemcpyDeviceToHost);
# 
#     // Print updated particle positions
#     printf("Updated particle positions:\n");
#     for (int i = 0; i < NUM_PARTICLES; i++) {
#         printf("Particle %d: (%f, %f, %f)\n", i, particles[i].x, particles[i].y, particles[i].z);
#     }
# 
#     // Free memory allocated for particles on host and device
#     free(particles);
#     cudaFree(d_particles);
# 
#     return 0;
# }
#

